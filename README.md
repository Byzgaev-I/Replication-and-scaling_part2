# Домашнее задание «Репликация и масштабирование. Часть 2»

## Задание 1

### Опишите основные преимущества использования масштабирования методами:
- активный master-сервер и пассивный репликационный slave-сервер;
- master-сервер и несколько slave-серверов;
Дайте ответ в свободной форме.

## Выполнение

### Преимущества масштабирования с использованием master и slave.
### Активный master-сервер и пассивный репликационный slave-сервер

В данной архитектуре один сервер работает как основной (master) и обслуживает все операции чтения и записи.   
Второй сервер (slave) получает копию данных через репликацию и находится в пассивном режиме.     
  
Основное преимущество такого подхода повышение отказоустойчивости.  
В случае выхода master из строя slave содержит актуальную копию данных и может быть использован для восстановления сервиса или быстрого переключения ролей.   
Это снижает риск потери данных и уменьшает время простоя системы.  
Дополнительно slave может использоваться для резервного копирования, аналитики или тестирования, не нагружая основной сервер.  

### Master-сервер и несколько slave-серверов

В этой модели master-сервер отвечает за операции записи, а несколько slave серверов используются для обработки запросов на чтение.
Ключевое преимущество это масштабирование чтения.   
Большинство приложений выполняют больше операций чтения, чем записи, поэтому распределение запросов между несколькими slave серверами, позволяет значительно увеличить   
производительность системы и количество одновременно обслуживаемых пользователей.  

Также повышается отказоустойчивость: при выходе из строя одного slave остальные продолжают обслуживать запросы.   
Недостатком наверное можно считать усложнение архитектуры и возможные задержки репликации, из-за которых данные на slave могут быть не полностью актуальными,   
но на практике как правило это компенсируется ростом производительности и масштабируемости.


## Задание 2

### План горизонтального и вертикального шаринга базы данных  

### Исходные условия:   

Имеется база данных, состоящая из трёх таблиц:
- пользователи
- книги
- магазины

Структура столбцов произвольная.
     
Наша цель разработать план масштабирования базы данных с использованием вертикального и горизонтального шаринга, описать принципы построения системы, разграничение данных между базами, режимы работы серверов и представить блок-схему.   



### 1. Вертикальный шардинг (разделение по смыслу данных).   
### Принцип  

Вертикальный шардинг заключается в логическом разделении данных по предметным областям.  
Каждая сущность выносим в отдельную базу данных, которая обслуживает только свою часть.  

### Реализация

Создаем три независимые базы данных:  

### UsersDB   

- таблица users  
- данные пользователей: id, имя, email, пароль, дата регистрации и т.д.  

### BooksDB 

- таблица books  
- данные о книгах: id, название, автор, жанр, цена и т.д.  

### ShopsDB    

- таблица shops  
- данные о магазинах: id, адрес, регион, тип магазина и т.д.  

### Принципы построения системы

- каждая база данных отвечает только за одну предметную область;  
- базы развиваются и масштабируются независимо;  
- снижение связности между данными;  
- упрощение контроля доступа и безопасности;  
- логические JOINы между таблицами выполняются на уровне приложения, а не СУБД.

### 2. Горизонтальный шардинг (разделение внутри сущностей)
### Принцип

Горизонтальный шардинг применяется для распределения больших объёмов данных внутри одной сущности между несколькими серверами.

### Шардинг выполняется по ключу шардинга:

- по диапазону id;  
- по региону;  
- по хешу идентификатора.   

### Пример реализации     

### Пользователи   

UsersDB_1 — пользователи с id 1–1 000 000  
UsersDB_2 — пользователи с id 1 000 001–2 000 000   

### Книги   
  
BooksDB_1 — книги с id 1–500 000  
BooksDB_2 — книги с id 500 001+  

### Магазины  
  
ShopsDB_EU — магазины Европы   
ShopsDB_ASIA — магазины Азии  

### Принципы работы  

- каждый шард содержит только часть данных;  
- приложение определяет нужный шард по ключу;  
- нагрузка равномерно распределяется между серверами;  
- система может масштабироваться практически без ограничений.  

 
###  3. Режимы работы серверов (replication + sharding)  

Для каждого шарда используется схема репликации master + slave.   
  
### Режимы:  
  
### Master  
  
- принимает все запросы на запись (INSERT, UPDATE, DELETE);  
- является источником репликации.  
  
### Slave   
  
- принимает запросы только на чтение (SELECT);  
- используется для масштабирования чтения и отказоустойчивости.  

### Репликация:  
  
- асинхронная;  
- данные копируются с master на slave с небольшой задержкой;  
- при падении master возможен failover.

### 4. Блок-схема архитектуры (логическая)

Client
  |
  v
Backend / API
  |
  v
Shard Router (логика выбора базы)
  |
  +--> UsersDB_shard_N (Master -> Slave)
  |
  +--> BooksDB_shard_N (Master -> Slave)
  |
  +--> ShopsDB_shard_N (Master -> Slave)































